From 1a6ea9d3f848a0f34145856a3a060f66607aee84 Mon Sep 17 00:00:00 2001
From: Felix Fietkau <nbd@nbd.name>
Date: Fri, 23 Aug 2024 16:23:30 +0200
Subject: [PATCH 9004/9006] wifi: mt76: mt7915: load efuse data unconditionally

This allows looking at the data through the 'otp' debugfs file.

Signed-off-by: Felix Fietkau <nbd@nbd.name>
---
 mt7915/eeprom.c | 62 +++++++++++++++++++++++++++++++------------------
 mt7915/mcu.c    | 11 +++++----
 mt7915/mt7915.h |  2 +-
 3 files changed, 47 insertions(+), 28 deletions(-)

diff --git a/mt7915/eeprom.c b/mt7915/eeprom.c
index bfdbc15a..7a15f234 100644
--- a/mt7915/eeprom.c
+++ b/mt7915/eeprom.c
@@ -115,38 +115,56 @@ out:
 	return ret;
 }
 
-static int mt7915_eeprom_load(struct mt7915_dev *dev)
+static int mt7915_eeprom_load_efuse(struct mt7915_dev *dev)
 {
+	u32 eeprom_blk_size = MT7915_EEPROM_BLOCK_SIZE;
+	u16 eeprom_size = mt7915_eeprom_size(dev);
+	u8 free_block_num;
+	u32 block_num, i;
+	u8 *buf;
 	int ret;
+
+	buf = devm_kzalloc(dev->mt76.dev, eeprom_size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	dev->mt76.otp.data = buf;
+	dev->mt76.otp.size = eeprom_size;
+
+	ret = mt7915_mcu_get_eeprom_free_block(dev, &free_block_num);
+	if (ret < 0)
+		return ret;
+
+	/* read eeprom data from efuse */
+	block_num = DIV_ROUND_UP(eeprom_size, eeprom_blk_size);
+	for (i = 0; i < block_num; i++) {
+		mt7915_mcu_get_eeprom(dev, buf, i * eeprom_blk_size);
+		buf += eeprom_blk_size;
+	}
+
+	/* efuse info isn't enough */
+	if (free_block_num >= 29)
+		return -EINVAL;
+
+	if (!dev->flash_mode)
+		memcpy(dev->mt76.eeprom.data, dev->mt76.otp.data, eeprom_size);
+
+	return 0;
+}
+
+static int mt7915_eeprom_load(struct mt7915_dev *dev)
+{
 	u16 eeprom_size = mt7915_eeprom_size(dev);
+	int ret;
 
 	ret = mt76_eeprom_init(&dev->mt76, eeprom_size);
 	if (ret < 0)
 		return ret;
 
-	if (ret) {
+	if (ret)
 		dev->flash_mode = true;
-	} else {
-		u8 free_block_num;
-		u32 block_num, i;
-		u32 eeprom_blk_size = MT7915_EEPROM_BLOCK_SIZE;
-
-		ret = mt7915_mcu_get_eeprom_free_block(dev, &free_block_num);
-		if (ret < 0)
-			return ret;
 
-		/* efuse info isn't enough */
-		if (free_block_num >= 29)
-			return -EINVAL;
-
-		/* read eeprom data from efuse */
-		block_num = DIV_ROUND_UP(eeprom_size, eeprom_blk_size);
-		for (i = 0; i < block_num; i++) {
-			ret = mt7915_mcu_get_eeprom(dev, i * eeprom_blk_size);
-			if (ret < 0)
-				return ret;
-		}
-	}
+	mt7915_eeprom_load_efuse(dev);
 
 	return mt7915_check_eeprom(dev);
 }
diff --git a/mt7915/mcu.c b/mt7915/mcu.c
index 76a3497a..e0ee6871 100644
--- a/mt7915/mcu.c
+++ b/mt7915/mcu.c
@@ -2836,7 +2836,7 @@ int mt7915_mcu_set_eeprom(struct mt7915_dev *dev)
 				 &req, sizeof(req), true);
 }
 
-int mt7915_mcu_get_eeprom(struct mt7915_dev *dev, u32 offset)
+int mt7915_mcu_get_eeprom(struct mt7915_dev *dev, u8 *buf, u32 offset)
 {
 	struct mt7915_mcu_eeprom_info req = {
 		.addr = cpu_to_le32(round_down(offset,
@@ -2845,7 +2845,6 @@ int mt7915_mcu_get_eeprom(struct mt7915_dev *dev, u32 offset)
 	struct mt7915_mcu_eeprom_info *res;
 	struct sk_buff *skb;
 	int ret;
-	u8 *buf;
 
 	ret = mt76_mcu_send_and_get_msg(&dev->mt76,
 					MCU_EXT_QUERY(EFUSE_ACCESS),
@@ -2854,11 +2853,13 @@ int mt7915_mcu_get_eeprom(struct mt7915_dev *dev, u32 offset)
 		return ret;
 
 	res = (struct mt7915_mcu_eeprom_info *)skb->data;
-	buf = dev->mt76.eeprom.data + le32_to_cpu(res->addr);
-	memcpy(buf, res->data, MT7915_EEPROM_BLOCK_SIZE);
+	if (res->valid)
+		memcpy(buf, res->data, MT7915_EEPROM_BLOCK_SIZE);
+	else
+		ret = -EINVAL;
 	dev_kfree_skb(skb);
 
-	return 0;
+	return ret;
 }
 
 int mt7915_mcu_get_eeprom_free_block(struct mt7915_dev *dev, u8 *block_num)
diff --git a/mt7915/mt7915.h b/mt7915/mt7915.h
index ac0b1f0e..12800fe1 100644
--- a/mt7915/mt7915.h
+++ b/mt7915/mt7915.h
@@ -472,7 +472,7 @@ int mt7915_mcu_set_fixed_rate_ctrl(struct mt7915_dev *dev,
 				   struct ieee80211_sta *sta,
 				   void *data, u32 field);
 int mt7915_mcu_set_eeprom(struct mt7915_dev *dev);
-int mt7915_mcu_get_eeprom(struct mt7915_dev *dev, u32 offset);
+int mt7915_mcu_get_eeprom(struct mt7915_dev *dev, u8 *buf, u32 offset);
 int mt7915_mcu_get_eeprom_free_block(struct mt7915_dev *dev, u8 *block_num);
 int mt7915_mcu_set_mac(struct mt7915_dev *dev, int band, bool enable,
 		       bool hdr_trans);
-- 
2.43.5

